\chapter{Background}
\label{theory_of_quantum_information}
\section{ Quantum Computing}

 In this chapter, the author will provide fundamental knowledge about quantum computing, including the concepts of quantum bits, quantum gates, quantum circuit and quantum compilation.

\subsection{Quantum Bit}

 A classical bit has two different states, which are 0 and 1.   Instead, those of a quantum bit (or \textbf{qubit} in short) are $|0\rangle$ and $|1\rangle$, each of which can be described as a vector.  
 $$|0\rangle = \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]$$
 $$|1\rangle = \left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right]$$

The state of a single 	qubit $|\psi\rangle$ can be described as follows.
$$ |\psi\rangle = \alpha |0\rangle + \beta |1\rangle \,(\alpha, \beta \in \mathbb{C}, |\alpha|^2+|\beta|^2=1)$$
 After the operation called measurement, the quantum state would be collapsed into either 0 or 1.  The measurement probability of 0 is $|\alpha|^2$ and that of 1 is $|\beta|^2$. In other words, a single qubit can take both states probabilistically at the same time.  For instance, a qubit can be $$|\psi\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle$$ which can be 50\% 0 and 50\% 1.
 
 \subsection{Bloch sphere}
 	Because $|\alpha|^2 + |\beta|^2 = 1$, the notation of a single qubit state can be represented like this.
	$$ |\psi\rangle = e^{i\gamma} (\cos{\frac{\theta}{2}} + e^{i\phi} \sin{\frac{\theta}{2}}) (\gamma, \phi, \theta \in \mathbb{R})$$ 
	Because $e^{i\gamma}$ is just a global state, it can be ignored and the same state can be rewritten like this.
	$$ |\psi\rangle =  \cos{\frac{\theta}{2}} + e^{i\phi} \sin{\frac{\theta}{2}} (\phi, \theta \in \mathbb{C})$$ 
	Because the equation above has two parameters,  any pure single qubit state can be considered as a point on the surface and its geometric representation is called \textbf{Bloch sphere}.
	\begin{figure}[h]
		\begin{center}
		\includegraphics[width=10cm]{img/blochsphere.png}
		\end{center}
		\caption{Bloch sphere}
	\end{figure}
	
 \subsection{Multi-Qubit State}
  The quantum state for multi-qubits is a \textbf{tensor product}of a state vector of each qubit.  The general notation of two qubit state is
   $$ |\psi\rangle = (\alpha |0\rangle + \beta |1\rangle) \otimes  (\gamma |0\rangle + \delta |1\rangle) $$
   $$ = \alpha \gamma |00\rangle + \alpha \delta |01\rangle + \beta \gamma |10\rangle + \beta \delta |11\rangle $$
  $$(\alpha, \beta, \gamma, \delta \in \mathbb{C}, |\alpha|^2+|\beta|^2+|\gamma|^2+|\delta|^2=1)$$
  
  For example, the state $|00\rangle$ is equal to 
  $$  \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
\otimes
 \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[
\begin{array}{c}
1 \\
0 \\
0 \\
0 \\
\end{array}
\right]$$

 However, some quantum states such as
 $$ |\psi\rangle = \frac{1}{\sqrt{2}}|00\rangle + \frac{1}{\sqrt{2}}|11\rangle$$ cannot be decomposed into quantum state of each qubit.  These special quantum states are called \textbf{entangled} states.
 
 

\newpage

\subsection{Quantum Gates}

 In this section, the author will talk about "logical gates" for quantum computers, which are called \textbf{quantum gates}.
 
\subsubsection{I gate}

I gate is equal to the 2x2 identity matrix, which is 

$$ I = \begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
$$

For example,
$$ I|0\rangle = \begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} 
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= |0\rangle
$$

$$ X|1\rangle = \begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} 
\left[
\begin{array}{c}
0 \\
1  \\
\end{array}
\right]
= \left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right]
= |1\rangle
$$


\subsubsection{X gate}

X gate flips the logical value of a qubit.

$$ X = \begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
$$

For example,
$$ X|0\rangle = \begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix} 
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right]
= |1\rangle
$$

$$ X|1\rangle = \begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix} 
\left[
\begin{array}{c}
0 \\
1  \\
\end{array}
\right]
= \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= |0\rangle
$$

\subsubsection{Y gate}

Y gate flips the logical value of a qubit and add an imaginary number.

$$ Y = \begin{bmatrix}
0 & -i \\
i & 0 \\
\end{bmatrix}
$$

For example,
$$ Y|0\rangle = \begin{bmatrix}
0 & -i \\
i & 0 \\
\end{bmatrix} 
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[
\begin{array}{c}
0 \\
i \\
\end{array}
\right]
= i|1\rangle
$$

$$ Y|1\rangle = \begin{bmatrix}
0 & -i \\
i & 0 \\
\end{bmatrix} 
\left[
\begin{array}{c}
0 \\
1  \\
\end{array}
\right]
= \left[
\begin{array}{c}
-i \\
0 \\
\end{array}
\right]
= -i|0\rangle
$$

\subsubsection{Z gate}

Z gate flips the phase of $ |1\rangle$

$$ Z = \begin{bmatrix}
1 & 0 \\
0 & -1 \\
\end{bmatrix}
$$

For example,
$$ Z|0\rangle = \begin{bmatrix}
1 & 0 \\
0 & -1 \\
\end{bmatrix} 
\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= |0\rangle
$$

$$ Z|1\rangle = \begin{bmatrix}
1 & 0 \\
0 & -1 \\
\end{bmatrix} 
\left[
\begin{array}{c}
0 \\
1  \\
\end{array}
\right]
= \left[
\begin{array}{c}
0 \\
-1 \\
\end{array}
\right]
= -|1\rangle
$$

\subsubsection{H gate}

H gate creates superposition.
$$ H = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1\\
1 & -1 \\
\end{bmatrix}
$$

For example,
$$ H|0\rangle = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1\\
1 & -1 \\
\end{bmatrix}\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
= \frac{1}{\sqrt{2}} \left[
\begin{array}{c}
1 \\
1 \\
\end{array}
\right]
= \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle)
$$

$$ H|1\rangle = \begin{bmatrix}
1 & 1\\
1 & -1 \\
\end{bmatrix} 
\left[
\begin{array}{c}
0 \\
1  \\
\end{array}
\right]
= \frac{1}{\sqrt{2}} \left[
\begin{array}{c}
1 \\
-1 \\
\end{array}
\right]
=\frac{1}{\sqrt{2}} (|0\rangle - |1\rangle)
$$

\subsubsection{Rx gate}
 An Rx gate rotate the given quantum circuit on the x-axis of the Bloch sphere.
 
 $$ Rx(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} & -i\sin{\frac{\theta}{2}} \\
 -i\sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}}  \\
\end{bmatrix}
$$
 
 For example,
$$ Rx(\theta)|0\rangle = \begin{bmatrix}
\cos{\frac{\theta}{2}} & -i\sin{\frac{\theta}{2}} \\
 -i\sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}}  \\
\end{bmatrix}\left[
\begin{array}{c}
1 \\
0 \\
\end{array}
\right]
=  \left[
\begin{array}{c}
\cos{\frac{\theta}{2}} \\
-i\sin{\frac{\theta}{2}} \\
\end{array}
\right]
= \cos{\frac{\theta}{2}}|0\rangle -i \sin{\frac{\theta}{2}} |1\rangle
$$

$$ Rx(\theta)|1\rangle = \begin{bmatrix}
\cos{\frac{\theta}{2}} & -i\sin{\frac{\theta}{2}} \\
 -i\sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}}  \\
\end{bmatrix}\left[
\begin{array}{c}
0 \\
1 \\
\end{array}
\right]
=  \left[
\begin{array}{c}
 -i\sin{\frac{\theta}{2}} \\
\cos{\frac{\theta}{2}}\\
\end{array}
\right]
=-i \sin{\frac{\theta}{2}}|0\rangle + \cos{\frac{\theta}{2}}|1\rangle
$$

\subsubsection{Ry gate}

 An Ry gate rotate the given quantum circuit on the y-axis of the Bloch sphere.
 
 $$ Rx(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} & -i\sin{\frac{\theta}{2}} \\
 -i\sin{\frac{\theta}{2}} & \cos{\frac{\theta}{2}}  \\
\end{bmatrix}
$$
\subsubsection{CNOT gate}

A CNOT gate involves two qubits, one is called \textbf{controlled qubit} and the other is called \textbf{target qubit}.  If the controlled qubit is 1, the bit value of the target qubit is flipped.

$$ CNOT = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}
$$

$$CNOT_{0,1}|10\rangle = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}
 \left[
\begin{array}{c}
0 \\
0 \\
1 \\
0 \\
\end{array}
\right]
=  \left[
\begin{array}{c}
0 \\
0 \\
0 \\
1 \\
\end{array}
\right] 
= |11\rangle 
$$

$$CNOT_{0,1}|11\rangle = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}
 \left[
\begin{array}{c}
0 \\
0 \\
0 \\
1 \\
\end{array}
\right]
=  \left[
\begin{array}{c}
0 \\
0 \\
1 \\
0 \\
\end{array}
\right] 
= |10\rangle 
$$

\subsubsection{Quantum gate for multi-qubit system}

Just like quantum state of a multi-qubit system, the composited quantum gates is the tensor product of quantum gates that are applied on each qubit.  \\For example, 
$$ X_0 \otimes X_1 = 
\begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
\otimes
 \begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
=  \begin{bmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
\end{bmatrix}
$$

Therefore, 
$$ X_0X_1 |00\rangle = 
\begin{bmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
\end{bmatrix}
\left[
\begin{array}{c}
1 \\
0 \\
0 \\
0 \\
\end{array}
\right] 
= \left[
\begin{array}{c}
0 \\
0 \\
0 \\
1 \\
\end{array}
\right] 
= |11\rangle
$$

$$ X_1 |00\rangle = 
I_0X_1 = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
\otimes
\begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
= \begin{bmatrix}
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}
$$
$$ I_0 X_1 |00\rangle
=  \begin{bmatrix}
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
\end{bmatrix}
\left[
\begin{array}{c}
1 \\
0 \\
0 \\
0 \\
\end{array}
\right] 
= \left[
\begin{array}{c}
0 \\
1 \\
0 \\
0 \\
\end{array}
\right] 
= |01\rangle
$$

\subsubsection{Measurement}

If a person measure a single qubit, he would get either 0 or 1 and that operation completely destroys the quantum state.  It will return 00, 01, 10, 11 in the case of two qubits.

\subsection{Quantum Circuit}

Here is the example of a quantum circuit.

$$
\begin{quantikz}
\ket{0} & \gate{H} & \qw & \ctrl{1} & \gate{X} & \gate{Y} &\meter{} && \\
\ket{0} & \gate{H} & \qw & \targ{} & \ctrl{1} & \gate{H} & \meter{}\\
\ket{0} & \gate{H} & \qw & \gate{X} & \targ{} & \qw & \meter{} \
\end{quantikz}
$$

Each horizontal line represents each qubit and the square boxes that contain alphabets mean single quantum gates.  The sign which involves a vertical line means a CNOT gate, and the box on the most right side indicates measurement. 

\subsection{Bell state}

In the chapter 1.3, the author mentions about a special type of quantum states called entangled states, and there are four specific quantum states called "Bell state", which are

$$ |\Phi^+\rangle = \frac{|00\rangle + |11\rangle}{\sqrt{2}}$$
$$ |\Phi^-\rangle = \frac{|00\rangle - |11\rangle}{\sqrt{2}}$$
$$ |\Psi^+\rangle = \frac{|01\rangle + |10\rangle}{\sqrt{2}}$$
$$ |\Psi^-\rangle = \frac{|01\rangle - |10\rangle}{\sqrt{2}}$$

\section{Distributed Computing}

 Distributed computing is the study of distributed system, which is a collection of several processors that are connected via network in order to solve a problem whose scale is much larger than what an individual processor can handle.  This type of computation involves message-passing between two physically separated processors to communicate and cooperate with each other by using pure HTTP, RPC, or message queues. [7] 
 
 \subsection{Characteristics of Distributed System}
 \par Distributed system has the following characteristics [8], which are,
 
 \begin{itemize}
 
      \item No common physical clock 
      
      This is the key feature of distributed system because the clock of each processor runs at a different rate, so no clock can keep synchronized even after a single physical clock cycle.  Instead, distributed system depends on logical clock, which is common time platform for the whole system.
      
     \item No shared memory
     
     Each processor in a distributed system has its own memory space, rather than the common physical memory.  This feature indicates that a distributed system does not share its global state.
     
     
      \item Geographical separation
      
      The processors in a distributed system is located in different places, but they do not have to communicate with wide area network (WAN).  Actually, the network of workstations (NOW) and the cluster of workstations (COW) are becoming increasing popular because companies can easily purchase cost-efficient, high-speed, and ready-made processors. 
      
     \item Autonomy and heterogeneity
     
     A distributed system can work together even if it contains various processors which have different size, speed and operating system as long as they cooperate with one another.  This situation is regarded as "loosely-coupled".
     
\end{itemize}

\subsection{Advantages Over Computation by a Single Processor}

Performing computation in a distributed manner provides the following advantages. [8]

\begin{itemize}
 
     \item{Computation by more than one entity}
     
     Applications such as money transfer (client-server) and reaching consensus among parties that are geographically separated (peer-to-peer) require information processing system that each processor can work together.
     
     \item{Resource sharing}
     
     Resource such as data in databases cannot be replicated because it is impossible or at least cost effective. Furthermore, allocating all the resource in just a single server is also not practical because the whole application would become unavailable if the server fails.  In order to solve these potential problems, the whole dataset is usually partitioned into several servers so that it can achieve more rapid access and higher reliability.
     
     \item{Access to geographically remote data and resources}
     
     Copying the whole dataset to every site is not desirable due to not only its predicted high cost, as I mentioned in the previous section, but also too sensitive.  Therefore, these large amount sensitive information, like user information collected by multinational cooperations are stored only in their central data centers and their oversea branches are only allowed to query them.
     
     \item{Enhanced reliability}
     
     Distributed system offers increased reliability due to its ability to replicate resource and achieve simultaneous execution of its given tasks. Also geographically distributed resources are highly unlikely crash or malfunction at the same time under normal circumstance.   This eliability entails several aspects.
     
     \begin{itemize}
     
      	\item{Availability}
	
	Resource become accessible at all times
	
      	\item{Integrity}
	
	The value and state of the resources should be always correct, especially users get concurrent access to those resources.	
	
      	\item{Fault-tolerance}
	
	Distributed system should be able to recover from its failure such as one of its server accidentally shutting down
	
    \end{itemize}
    
    
   \item{Increased performance / cost ratio}
   
     By resource sharing and access to geographically distant data, the performance and cost ratio of distributed system will improve more than using special parallel machines, this is particularly true of the NOW (network of workstation) setting.
     
\end{itemize}

\subsection{Task Allocation Problem}

Here are some definitions of the task allocation problem in distributed system.[9]
Given a distributed system $G = <V, E>$, where V is the set of nodes and E is the set of communication link between two different nodes, i.e. $\forall v_i. v_j \in V, \exists <v_i, v_j> \in E$.  The set of the resources in $a_i$ is $R_{a_i}$ and that required by the task $t$ is $R_t$.

\begin{enumerate}
	\item{$R_t \subseteq$ $\bigcup_{\forall a_i \in A_t} R_{a_i}$}
	\item{The objective should be either minimizing the execution time [10] or maximizing reliability [11]}
	\item{The nodes in $A_t$ can execute the allocated task under the constraint of the network structure $\forall a_i, a_j \in A_t \Rightarrow P_{ij} \subseteq E$ where $P_{ij}$ denotes the path between $a_i$ and $a_j$}
\end{enumerate}

Task allocation is known to be a NP-problem. [12]

\subsection{Distributed Task Allocation Algorithms}

Due to the fact that task allocation problem is classified as NP-hard, many works have proposed heuristic functions for distributed task allocations in various settings.  Here, the author is going to introduce a simple objective function presented in the paper [13], which is this work is based on.

It is assumed that a multicomputer system consists of $N$ heterogeneous processors with some amount of computational power and the size of memory.  Also, the given program includes $M$ communicating tasks, which is the nodes in the task interaction graph $G(V, E)$ ($V$ is $M$ communicating tasks and E is a set of communication relationship between two tasks).

The objective of this task allocation is to minimize the total execution time. In other words, the author has to come up with the optimal allocation $A$, which $A(i) = p$ indicates that the task $i$ is allocated to the processor $p$ and $TASKS_p$ is a group of tasks that are allocated to a processor $p$.

 The total execution in the heterogeneous computing cluster is same as the execution time in the most heavily loaded processor.  Two main types of costs should be considered.
 
 One is the execution cost.  The execution load in the processor $p$ is the cost of processing all the tasks that are assigned to $p$ for the allocation $A$. Suppose $C_{ip}$ is the cost of processing the task $i$ on the processor $p$, then the total execution cost on the processor $p$ is $$EXEC_p = \sum_{task \in  TASKS_p} C_{task, p}$$
 
  The other cost is the communication cost, which can be calculated by the following formula.
  
  $$COMM_p = \sum_{task \in TASKS_p} \sum_{(i=j), \\(i, j) \in E , \\ A(j) \neq p} d_{ij} * cc_{avg}$$. $d{ij}$ is the data sent between two communicating tasks between $i$, $j$ and $cc_{avg}$ is the average amount of transferring a data unit through the network transmission media.
  
 Therefore, the total cost for the processor $p$ is $$COST_p = EXEC_p + COMM_p$$.
 Because the total execution time is equal to the execution of the most heavily loaded processor, the total execution time can be described as following.
 $$ COST =  max \{COST_p | 1 \leq p \leq n\}$$
 
 Therefore, the object function is $$min \,\,COST$$


\subsection{Models of Process Communication}

There are two basic models of process communication.[13] One is \textit{synchronous} communication, which the sender process blocks its execution until it receives "acknowledgement " (or "ack" in short) from the receiver, which indicates that the receiver accepted the delivered message. In other words, the sender and receiver synchronize with each other, in order to adjust their timings to cooperate.
\par On the other hand, the other model, which is \textit{asynchronous} execution does not require synchronization between the sender and the receiver.  Therefore, the sender executes its following task right after it delivers its message to the receiver. 

\section{Distributed Quantum Computing}
 
  Performing quantum computation on a cluster of middle-sized quantum processors is an easier approach compared to build a large single processor due to its lower physical requirement to build each processor [13].  \\
This chapter explains several components that consists of distributed quantum computing system.

\subsection{Distributed Quantum Algorithms}

Distributed version of Shor's algorithm[14] and Grover's algorithm[15], both of which takes remote CNOTs (which will be discussed in a  later subsection) were presented in 2004 and 2012, respectively. 
However, the quantum circuits shown in these studies are physical ones, in other words, something that will be implemented directly on physical hardware, not something that users will implement in their programs. 

\subsection{Distributed Quantum Compiler}

 Quantum compiler is a software to optimize a quantum circuit defined in the given program to reduce the number of quantum gates and alleviate the effect of physical noise on that quantum state, and map that to the real hardware so that it will satisfy the connectivity constraint on that hardware [16].  Just like the case of a local quantum software, distributed quantum computer also needs its distributed version, which is called "distributed quantum compiler" in order to convert some CNOT gates into remote CNOTs and optimize both its execution time and the number of quantum gates in total, especially that of non-local operations.  This work focuses on the methodology to optimize the total execution time over the distributed quantum computing setting.
 
 \subsection{Gate-Teleportation-Based Non-Local CNOT}
 
Non-local operations are controlled operations between two qubits on two different processors there are three main approach to achieve them.

The first operation is the gate teleporation approach, and is also called non-local quantum gates [17] and telegate [18].  Here is the quantum circuit that achieve this operation.

Suppose that a person would like to apply a non-local CNOT between $|a_0\rangle$ on one processor and $|b_0\rangle$ on the other processor.  In order to do this, he has to prepare a new bell pair between these two processors.  ($|p_i\rangle$ in the following circuit diagram comes from p in $|\psi (psi)^+\rangle$)

 \begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=10cm]{img/non-local-cnot.png}
			\caption{Quantum circuit for a non-local CNOT gate}
			\label{Fig1}
		\end{center}
	\end{figure}
	
\newpage

\subsection{Quantum Teleportation}

  Unlike classical communication, quantum states cannot be just copied and transmit to other nodes due to the no-cloning theorem, which forbids duplication of any quantum state.  However, a method called quantum teleportation[19] was proposed, which overcomes the restriction and allows sender to transmit single qubit state to a distant location. 
 		
This method requires both the single qubit state and a new Bell pair, and also the sender have to prepare two qubits and the receiver have to prepare one qubit.  After applying a CNOT gate and an H gate in the figure above, the sender have to measure both qubits and send those measurement results over the classical network.  After the receiver get those measurement results and apply some quantum gates if the measurement results of corresponding qubits on the sender's side are 1, in order to correct on the quantum state on the receiver's side.

	\begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=10cm]{img/teleportation.png}
			\caption{Quantum circuit for quantum teleportation}
			\label{Fig2}
		\end{center}
	\end{figure}
\newpage
\subsection{Quantum-Teleportation-Based Non-Local CNOT}

 The second approach for performing a non-local CNOT gate is based on quantum teleportation mentioned in the previous section.  This approach assumes that every quantum processor has something called "communication qubits", which is a qubit that serves for communication purpose, unlike those used for computation purpose, which are called "data qubits".
 
 \begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=10cm]{img/teleportation-cnot.png}
			\caption{The full quantum circuit for a teledata non-local controlled-U gate}
			\label{Fig3}
		\end{center}
	\end{figure}
	
\subsection{Data-Qubit-Swapping-Based Non-Local-CNOT}

The last approach for the non-local CNOT gate aims to sort qubits in the quantum processors so that each CNOT gates would be executed on the neighboring processors. (the paper [20] assumes linear topology)

\begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=10cm]{img/data-swapping-before.png}
			\caption{The quantum circuit before the data qubit swapping occurs}
			\label{Fig3}
		\end{center}
	\end{figure}
	
\begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=10cm]{img/data-swapping-after.png}
			\caption{The quantum circuit after the data qubit swapping occurs}
			\label{Fig3}
		\end{center}
	\end{figure}
\newpage

\begin{algorithm}
 \caption{Algorithm for Data-Qubit Swapping}
 \begin{algorithmic}[1]
  \Require n-qubit circuit layer L with mod(n, 4) = 0 and $\frac{n}{2}$ CNOTs
  \Ensure  layer L with each CNOT operating on neighbor qubits
 \Function {Sort}{L}
    \If {$\exists \, CNOT(q_i, q_j)$ with $i, j \leq \frac{n}{2}$} 
   	\State{// $\exists \, CNOT(q_k, q_l)$ with $k, l > \frac{n}{2}$}
	\State{SWAP ($q_{i+1}$, $q_j$)}
	\State{SWAP($q_{k+1}$, $q_l$)}
	\State{L = L \textbackslash \{$q_i$,  $q_{i+1}$,  $q_{k}$,  $q_{k+1}$\}}
    \Else
	\State{// $\exists \, CNOT(q_{\frac{n}{2}}, q_l)$ with $l > \frac{n}{2}$}
	\State{// and $\exists \, CNOT(q_i, q_{l-1})$ with $i < \frac{n}{2}$}
	 \State{SWAP ($q_{\frac{n}{2}}$, $q_{l-1}$)}
	  \State{SWAP ($q_i$, $q_{\frac{n}{2}-1}$)}
	  \State{L = L \textbackslash \{$q_{\frac{n}{2}-1}$,  $q_{\frac{n}{2}}$,  $q_{l-1}$,  $q_{l}$\}}
    \EndIf
    
    \If {$L \neq \emptyset$}
    	\State{Sort(L)}
    \EndIf
    
\EndFunction

 \end{algorithmic} 
 \end{algorithm}



 \subsection{Quantum Processor}
  A quantum processor, which corresponds to individual processor in a classical distributed system, has several qubits and links between two qubits in a limited topology.
  
  	 \begin{figure}[h]
  		\begin{center}
  			\includegraphics[width=5cm]{img/processor.png}
			\caption{An example of the layout of a quantum processor}
			\label{Fig4}
		\end{center}
	\end{figure}
	
Usually, qubits in a current quantum processor are connected with a few neighboring qubits due to its physical restriction on a hardware.  Also, the error rate of a CNOT gate is much higher than that of a single quantum gate.
 
 \subsection{Communication Link for Distributed Quantum Computing}
Networking between two quantum processors need two types of communication links, which are classical links that transmit measurement results in the process of either telegate or teledata non-local CNOT gate, and quantum links that prepare create entanglement between the two qubits between the two neighboring quantum processors, or communication qubits of both processors.    

%\end{document}
%%% Local Variables:
%%% mode: japanese-latex
%%% TeX-master: "../thesis"
%%% End: